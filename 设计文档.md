# 设计文档

## 词法分析

词法分析的目的是将连续的文本拆分成符合词法约束的单词。

`Lexer\` 目录下包含 `Lexer.java`，`Token.java`，`TokenType.java`。其中 `Lexer.java` 是词法分析的主要处理过程，`Token.java` 保存了每一个词法单元的信息，`TokenType.java` 记录词法成分。

`Lexer` 类采用单例模式设计。在分析时将整个字符串传给 `Lexer.LEXER.content`。在识别词法成分时将词法成分分为 `Word`，`Number`，`Symbol` 进行分析。在分析 `Word` 时若为关键字则保存为关键字，否则保存为 `Ident`。跳过注释、识别字符串等统一在处理 `Symbol` 的过程中处理。

## 语法分析

采用递归下降的方式进行语法分析。对于每种语法成分都建立了一个类，便于在语法分析时尽量多的保存语法语义信息。错误处理也在语法分析阶段进行处理。

通过 `Lexer.LEXER.peek` 和 `Lexer.LEXER.next` 方式遍历词法节点。对于多义语法成分，采用预读方式（`Lexer.LEXER.preView`）判断分支。

在语法分析阶段进行错误处理。因此在语法分析阶段建立了简单的符号表以供错误处理，在进行语法分析后只保留全局语法信息（`Vardef`，`ConstDef`，`FuncDef`），局部信息均被舍弃，符号表在下个阶段重新在运行时建立。

## 中间代码生成

我进行了 `Pcode` 和 `llvm` 的代码生成工作。

## PCode

对于 `PCode`，我采用直接解释运行的策略。 因为已经在语法分析阶段保存了足量的语义信息，所以可以直接由语法树节点进行解释执行。

### 内存管理

动态解释执行的关键在于做好内存管理。对于内存管理，我的方案是使用 `RuntimeStack` 动态运行栈。运行栈内保存变量和父栈指针，在查找变量时可以通过循环查找父栈的方式。

在运行期间遇到变量定义则将变量加入到运行栈中。退出运行栈时自动销毁运行栈。

在执行时，将全局变量保存在全局变量区。所有栈向上查找最终都会指向全局变量区。

### 变量定义

通过 `Var` 定义、保存变量的信息。将变量分成两种类型：普通变量和数组变量。数组变量是递归定义的，通过递归定义可以支持多维数组。

### 控制流

对于条件选择，通过对条件语句 `cond` 的判断决定后续进入哪个分支。对于循环语句，循环执行语句直至满足退出条件或捕捉到 `return` 或 `continue`。

遇到 `continue` 和 `break` 时，会抛出一个异常，由执行这个循环的函数负责捕获。捕获后执行后续代码。

遇到 `return` 时，抛出一个携带返回值的异常，由调用者负责捕获。

### 函数调用

函数调用的流程为：建立临时栈，将函数参数压入临时栈，保存当前栈，将当前栈指向临时栈，执行函数内部代码。执行完毕后恢复当前栈。

传入参数为数组时，直接获取数组的引用，将引用复制给函数参数。

## LLVM

在设计 `LLVM` 时，花费了比较多的精力和时间。生成的 `LLVM` 指令类型如下：

```text
add,    // <result> = add <ty> <op1>, <op2>
sub,    // <result> = sub <ty> <op1>, <op2>
mul,    // <result> = mul <ty> <op1>, <op2>
sdiv,   // <result> = sdiv <ty> <op1>, <op2>
srem,   // <result> = srem <ty> <op1>, <op2>
icmp,   // <result> = icmp <cond> <ty> <op1>, <op2>
and,    // <result> = and <ty> <op1>, <op2>
or,     // <result> = or <ty> <op1>, <op2>
call,   // <result> = call [ret attrs] <ty> <fnptrval>(<function args>)
alloca, // <result> = alloca <type>
load,   // <result> = load <ty>, <ty>* <pointer>
store,  // store <ty> <value>, <ty>* <pointer>
getelementptr,  // <result> = getelementptr <ty>, * {, [inrange] <ty> <idx>}*
                // <result> = getelementptr inbounds <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
phi,    // <result> = phi [fast-math-flags] <ty> [ <val0>, <label0>], ...
zext,   // <result> = zext <ty> <value> to <ty2>
trunc,  // <result> = trunc <ty> <value> to <ty2>
br,     // br i1 <cond>, label <iftrue>, label <iffalse>
        // br label <dest>
ret,    // ret <type> <value> ,ret void
label,
```

在设计过程中遵循万物皆 `value` 的思想。所有的指令均是一种 `value`，这样指令之间可以相互使用，构造出 `SSA`。

### 常量优化

对于常量做了特定的优化。对于普通常量，直接在编译时全部替换为常数。对于常量数组，在编译时确定其内部值。在生成代码时，对表达式进行常量优化：若一个表达式完全由常量和常数组成，则直接计算出该表达式的值，用常数替换表达式。

### 短路求值

对于短路求值，我的做法是在 visit LOrExp 和 LAndExp 时传入短路情况应当跳转的地点。在 visit 子节点时设置对应的跳转出口。

因为 llvm 中 icmp 的值为 i1 类型，所以在每次进行比较之后我先将其位扩展至 i32。通过与零比较判断条件是否为真。
