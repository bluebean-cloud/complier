# 设计文档

## 参考编译器

在做 llvm 的时候简单参考了一下 **那一年喵喵队变成了光** 的架构，除此之外整个编译器基本由我个人独自设计完成。（其中部分设计为我和同学讨论后受启发设计而出）

## 编译器总体设计

### 总体结构

我的编译器由以下几个子模块构成：词法分析器（**lexer**）、语法分析器（**parser**）、解释执行器（**executor**）、中端架构（**mir**）、观察者（**visitor**）、后端（**backend**）、通用工具类（**util**）构成。

接下来分别介绍各个子模块的设计。

### 词法分析器

分析前将保留的关键字和对应的属性保存到一个 **HashMap** 中，在分析单词时查看 **HashMap** 中是否存在该单词，从而判断是否为关键字。

词法分析阶段保存的信息包括：单词类型（**tokenType**）、字面量（**content**）、常数值（**number**）、行号（**line**）

### 语法分析器

语法分析器通过递归下降的方式构造。其中 **Scope** 类在语法分析过程中保存了符号表信息，并且在语法阶段进行错误处理。

### 解释执行器

实现了一个可以解释执行语法树的解释器，即可直接解释执行 **sysy** 语言。**RuntimeStack** 类用于模拟运行栈，通过抛出异常的方式控制执行流。

### 中端架构

中端采用 **llvm** 架构，实现了 **SSA**，通过 **Use** 保存调用和被调用的关系。其中 **Instruction** 类实现了指令类，也是实际上的 **User** 类。此外定义了一系列派生类，包括基本快（**Basic Block**、**Function**、**FunctionParam**、**GlobalVar**、**StringLiteral**。

其中 **StringLiteral** 的目的是为了优化输出字符串。但是由于时间关系没有进行这方面的优化。在处理 **printf** 时采用 **putch-putint** 的方式。

### Visitor

采用递归的方式对整颗语法树遍历，根据对应的语法规则选择相应的 **llvm** 指令。

### 后端

后端进行了两个工作：指令翻译（**llvm to MIPS**）和寄存器分配。指令翻译采用了保守的方法，使用了很多伪指令。寄存器分配采用了线性扫描寄存器分配法。

### 工具类

工具类是一些需要跨越模块使用的类。包括：**ErrorLog** （记录错误处理信息）、**GlobalConfigure**（全局设置，包括是否开启优化，是否开启 **DBUG** 模式等）、**Judge**（一个自己实现的进行一些判断和断言的工具类）

## 词法分析

词法分析的目的是将连续的文本拆分成符合词法约束的单词。

`Lexer\` 目录下包含 `Lexer.java`，`Token.java`，`TokenType.java`。其中 `Lexer.java` 是词法分析的主要处理过程，`Token.java` 保存了每一个词法单元的信息，`TokenType.java` 记录词法成分。

`Lexer` 类采用单例模式设计。在分析时将整个字符串传给 `Lexer.LEXER.content`。在识别词法成分时将词法成分分为 `Word`，`Number`，`Symbol` 进行分析。在分析 `Word` 时若为关键字则保存为关键字，否则保存为 `Ident`。跳过注释、识别字符串等统一在处理 `Symbol` 的过程中处理。

## 语法分析

采用递归下降的方式进行语法分析。对于每种语法成分都建立了一个类，便于在语法分析时尽量多的保存语法语义信息。错误处理也在语法分析阶段进行处理。

通过 `Lexer.LEXER.peek` 和 `Lexer.LEXER.next` 方式遍历词法节点。对于多义语法成分，采用预读方式（`Lexer.LEXER.preView`）判断分支。

在语法分析阶段进行错误处理。因此在语法分析阶段建立了简单的符号表以供错误处理，在进行语法分析后只保留全局语法信息（`Vardef`，`ConstDef`，`FuncDef`），局部信息均被舍弃，符号表在下个阶段重新在运行时建立。

## 中间代码生成

我进行了 `Pcode` 和 `llvm` 的代码生成工作。

## PCode

对于 `PCode`，我采用直接解释运行的策略。 因为已经在语法分析阶段保存了足量的语义信息，所以可以直接由语法树节点进行解释执行。

### 内存管理

动态解释执行的关键在于做好内存管理。对于内存管理，我的方案是使用 `RuntimeStack` 动态运行栈。运行栈内保存变量和父栈指针，在查找变量时可以通过循环查找父栈的方式。

在运行期间遇到变量定义则将变量加入到运行栈中。退出运行栈时自动销毁运行栈。

在执行时，将全局变量保存在全局变量区。所有栈向上查找最终都会指向全局变量区。

### 变量定义

通过 `Var` 定义、保存变量的信息。将变量分成两种类型：普通变量和数组变量。数组变量是递归定义的，通过递归定义可以支持多维数组。

### 控制流

对于条件选择，通过对条件语句 `cond` 的判断决定后续进入哪个分支。对于循环语句，循环执行语句直至满足退出条件或捕捉到 `return` 或 `continue`。

遇到 `continue` 和 `break` 时，会抛出一个异常，由执行这个循环的函数负责捕获。捕获后执行后续代码。

遇到 `return` 时，抛出一个携带返回值的异常，由调用者负责捕获。

### 函数调用

函数调用的流程为：建立临时栈，将函数参数压入临时栈，保存当前栈，将当前栈指向临时栈，执行函数内部代码。执行完毕后恢复当前栈。

传入参数为数组时，直接获取数组的引用，将引用复制给函数参数。

## LLVM

在设计 `LLVM` 时，花费了比较多的精力和时间。生成的 `LLVM` 指令类型如下：

```mips
add,    // <result> = add <ty> <op1>, <op2>
sub,    // <result> = sub <ty> <op1>, <op2>
mul,    // <result> = mul <ty> <op1>, <op2>
sdiv,   // <result> = sdiv <ty> <op1>, <op2>
srem,   // <result> = srem <ty> <op1>, <op2>
icmp,   // <result> = icmp <cond> <ty> <op1>, <op2>
and,    // <result> = and <ty> <op1>, <op2>
or,     // <result> = or <ty> <op1>, <op2>
call,   // <result> = call [ret attrs] <ty> <fnptrval>(<function args>)
alloca, // <result> = alloca <type>
load,   // <result> = load <ty>, <ty>* <pointer>
store,  // store <ty> <value>, <ty>* <pointer>
getelementptr,  // <result> = getelementptr <ty>, * {, [inrange] <ty> <idx>}*
                // <result> = getelementptr inbounds <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
phi,    // <result> = phi [fast-math-flags] <ty> [ <val0>, <label0>], ...
zext,   // <result> = zext <ty> <value> to <ty2>
trunc,  // <result> = trunc <ty> <value> to <ty2>
br,     // br i1 <cond>, label <iftrue>, label <iffalse>
        // br label <dest>
ret,    // ret <type> <value> ,ret void
label,
```

在设计过程中遵循万物皆 `value` 的思想。所有的指令均是一种 `value`，这样指令之间可以相互使用，构造出 `SSA`。对于 `value` 维护了 `use` 链，便于做优化。

### 常量优化

对于常量做了特定的优化。对于普通常量，直接在编译时全部替换为常数。对于常量数组，在编译时确定其内部值。在生成代码时，对表达式进行常量优化：若一个表达式完全由常量和常数组成，则直接计算出该表达式的值，用常数替换表达式。

### 短路求值

对于短路求值，我的做法是在 visit LOrExp 和 LAndExp 时传入短路情况应当跳转的地点。在 visit 子节点时设置对应的跳转出口。

因为 llvm 中 icmp 的值为 i1 类型，所以在每次进行比较之后我先将其位扩展至 i32。通过与零比较判断条件是否为真。

## MIPS

进行了 MIPS 代码生成工作和寄存器分配工作。

### 代码生成

代码生成采取了朴素的翻译方式，将每一条 **llvm** 指令使用 **mips** 的对应指令进行翻译。略微进行了指令选择（如将 `subu %2 %1 10` 翻译成 `addiu %2 %1 -10`）。

目前已生成的指令列表如下：

```
ADDU,
ADDUI,
SUBU,
MUL,
DIV,
REM,
LI,
NOP,
J,
JAL,
JR,
BNEZ,
SLT,
SLTI,
SLE,
SGT,
SGE,
SEQ,
SNE,
LW,
SW,
LA,
SYSCALL,
```

### 寄存器分配

寄存器分配采用线性扫描寄存器分配法。特点是简单，易于实现，且效率高。

算法的主要步骤如下：

预处理工作：遍历一遍所有指令，确定所有寄存器的生命周期。将寄存器按照生命周期的起点排序。同时初始化物理寄存器池，设可用的物理寄存器数量为 *R*。

1. 按照生命周期起点从小到大每次取出一个虚拟寄存器。
2. 设 curTime 为当前虚拟寄存器的生命周期起点。将所有生命周期终点 < curTime 的虚拟寄存器所分配到的物理寄存器释放掉。
3. 若当前活跃的物理寄存器数量 == *R*，则需要溢出（spill）一个虚拟寄存器到内存中。否则从物理寄存器池中取出一个分配给这个虚拟寄存器。
4. 回到第一步重复直至遍历完所有的寄存器。

选择策略：选择当前活跃虚拟寄存器中生命周期结束最迟的，将其 spill 到内存中。

注：该寄存器分配法针对的是不跨越基本块的虚拟寄存器。但是在我当前的架构下所有寄存器都不会跨越基本块（除调用函数），于是可以采用这个方法分配寄存器。

在调用函数时，需要将当前使用到的寄存器保存到运行栈中。

### spill

需要 spill 到内存中的寄存器会在运行栈中开辟一段空间存值。当需要使用到这个值时，将其取出到未使用的寄存器中；当需要存储这个值时，将其存储到内存中。

## 错误处理设计

在语法处理阶段进行错误处理。对于语法错误，在读入词语时进行断言，若不为预期的符号则报错。

对于语义错误，在定义变量时首先查找符号表，查找同层是否存在重定义，若不报错则将信息记录至符号表中。

## 代码优化设计

代码优化进行的工作如下：

1. 常量化简：对于出现在表达式中的常量，尽可能地直接进行计算求值。
2. 函数化简：尝试使用解释器解释语法树，遇到 **getint** 则停止解释。在解释停止之前，对于主函数调用的函数，若其可以被求值且不存在副作用，则将其替换为常量。
