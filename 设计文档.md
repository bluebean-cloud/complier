# 设计文档

## 词法分析

词法分析的目的是将连续的文本拆分成符合词法约束的单词。

`Lexer\` 目录下包含 `Lexer.java`，`Token.java`，`TokenType.java`。其中 `Lexer.java` 是词法分析的主要处理过程，`Token.java` 保存了每一个词法单元的信息，`TokenType.java` 记录词法成分。

`Lexer` 类采用单例模式设计。在分析时将整个字符串传给 `Lexer.LEXER.content`。在识别词法成分时将词法成分分为 `Word`，`Number`，`Symbol` 进行分析。在分析 `Word` 时若为关键字则保存为关键字，否则保存为 `Ident`。跳过注释、识别字符串等统一在处理 `Symbol` 的过程中处理。

## 语法分析

采用递归下降的方式进行语法分析。对于每种语法成分都建立了一个类，便于在语法分析时尽量多的保存语法语义信息。错误处理也在语法分析阶段进行处理。

通过 `Lexer.LEXER.peek` 和 `Lexer.LEXER.next` 方式遍历词法节点。对于多义语法成分，采用预读方式（`Lexer.LEXER.preView`）判断分支。

在语法分析阶段进行错误处理。因此在语法分析阶段建立了简单的符号表以供错误处理，在进行语法分析后只保留全局语法信息（`Vardef`，`ConstDef`，`FuncDef`），局部信息均被舍弃，符号表在下个阶段重新在运行时建立。

## 解释运行

因为已经在语法分析阶段保存了足量的语义信息，所以可以直接由语法树节点进行解释执行。

动态解释执行的关键在于内存管理。

将变量细分为整型和数组两种类型 `Var->SimpleInt, Array`，其中 `Array` 支持递归定义，即 `Array` 的数组成员可以是 `Array` 成分，从而可以定义“多维数组”。

首先将内存视图划分为全局变量区（堆视角）和局部变量区域（栈视角）。

对于全局变量，将全局变量都保存在全局变量区。

对于局部变量，采取类似符号表的栈式管理结构。其中每次运行函数都拥有一个独立的栈，所有函数栈的最外层都指向全局变量区。

在语句运行过程中，对 `Block`、`For`、`If` 等需要开启新的栈的语句都建立新栈，在执行完对应的语句后回收栈区域。

对于函数的指针传参，将分析得到的 `Array` 引用复制到实参列表，从而实现通过指针访问数组内容（借助 Java 的语法特性）。

对于循环语句，在运行过程中会记录 `for` 语句的 `forStmt` 以及循环出口，在遇到 `break`、`continue`、时可通过抛出、处理异常的形式结束或从头开始循环。

对于 `exp`、`cond` 的解析，在语法分析阶段已经将左递归文法改写为 `BNF` 范式，故语法结构是扁平的，可以从左往右遍历访问、处理语法成分。访问到 `UnaryExp` 时依据 `UnaryExp` 的不同类型分别处理计算返回值。

在函数调用时，首先解析获取函数各个参数的值，然后利用值构造函数实参，建立新的栈空间，开启一个新的函数。由于是动态执行的，所有所有值都可以在运行时动态得到。

## 后续工作

在完成解释工作后，下一步的目标是建立多线程机制，从而完成和用户的互动。即最后的目标效果如下：

```shell
$ int a = 10, b = 10, arr[10];
> definied: a<-10 b<-10,
$ int c = a + b;
> c: 20
$ int f(int a, int b) {
$   return a + b; 
$ }
> definied: int f(int, int)
$ for (a = 1; a < 5; a = a + 1) {
$   printf("%d\n", a);
$ }
> 1
> 2
> 3
> 4
> Execute for loop
$ f(c, 1);
> f: 21
$ int main() {
$   return 0;
$ }
> main func returns 0, Interpreter execution completed. 
```

